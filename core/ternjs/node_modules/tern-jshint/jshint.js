(function(mod) {
  if (typeof exports == "object" && typeof module == "object") { // CommonJS
    return mod(require("tern/lib/infer"), require("tern/lib/tern"), require("jshint/src/jshint").JSHINT, require("jshint/src/cli"));
  }
  if (typeof define == "function" && define.amd) // AMD
    return define([ "tern/lib/infer", "tern/lib/tern", "jshint/src/jshint", "jshint/src/cli" ], mod);
  mod(tern, tern, JSHINT);
})(function(infer, tern, JSHINT, cli) {
  "use strict";
  
  var bogus = [ "Dangerous comment" ];

  var warnings = [ [ "Expected '{'",
                     "Statement body should be inside '{ }' braces." ] ];

  var errors = [ "Missing semicolon", "Extra comma", "Missing property name",
                 "Unmatched ", " and instead saw", " is not defined",
                 "Unclosed string", "Stopping, unable to continue" ];
  
  var slashAtEndRegEx = /\/$/;
  
  var pathLastSegmentIsolationRegEx = /([^\/]*)\/*$/;
  
  var fileNameRegEx = /([^\\]+)\.[^\\]+$/;
  
  var doubleAsteriskAtEndRegEx = /\*\*$/;
  
  function cleanup(error) {
    // All problems are warnings by default
    fixWith(error, warnings, "warning", true);
    fixWith(error, errors, "error");

    return isBogus(error) ? null : error;
  }

  function fixWith(error, fixes, severity, force) {
    var description, fix, find, replace, found;

    description = error.description;

    for ( var i = 0; i < fixes.length; i++) {
      fix = fixes[i];
      find = (typeof fix === "string" ? fix : fix[0]);
      replace = (typeof fix === "string" ? null : fix[1]);
      found = description.indexOf(find) !== -1;

      if (force || found) {
        error.severity = severity;
      }
      if (found && replace) {
        error.description = replace;
      }
    }
  }

  function isBogus(error) {
    var description = error.description;
    for ( var i = 0; i < bogus.length; i++) {
      if (description.indexOf(bogus[i]) !== -1) {
        return true;
      }
    }
    return false;
  }

  function normPath(name) { return name.replace(/\\/g, "//"); }
  
  function JSHintConfig(server, options) {
    this.validPath = true;
    if (options.config) {
      // JSHint config is stored in the .tern-project
      this.config = options.config;
      this.init();
    } else if (options.configFile) {
      // JSHint config is stored in a .jshintrc config file.      
      this.validPath = false;
      this.configFile = options.configFile;
      var filepath = this.filepath = normPath(options.configFile);
      this.projectDir = server.options.projectDir;
      // Override cli.error to avoid calling cli.exit when cli.exit is called in cli.loadConfig.
      require("jshint/node_modules/cli").error = function(msg) {
        throw new Error(msg);
      }
    }
  }
  
  JSHintConfig.prototype.init = function() {
    var config = this.config = JSON.parse(JSON.stringify(this.config || {}));    
    this.globals = null;
    if (config.globals) {
      this.globals = config.globals;
      delete config.globals;
    }
    delete config.dirname;    
  }
  
  JSHintConfig.prototype.update = function() {
    try {
      var filepath = this.filepath;
      this.config = cli.loadConfig(filepath);
      this.init();
      this.error = null;
    } catch(e) {
      this.error = String(e);
    }
  }
  
  JSHintConfig.prototype.getConfig = function() {
    if (this.validPath) return this.config;
    var filepath = this.filepath;    
    var fs = require("fs"), projectDir = this.projectDir;
    if (!fs.existsSync(filepath)) {
      // try if config file is hosted inside project
      filepath = normPath(projectDir) + "//" + filepath;
      if (!fs.existsSync(filepath)) {
        this.error = "Cannot find JSHint config files ['" + this.filepath + "', '" + filepath + "']";
      } else {
       this.filepath = filepath; 
       this.validPath = true; 
      }      
    } else {
      this.validPath = true; 
    }
    if (this.validPath) {
      delete[this.error];
      var _this = this;
      // watch the .jshintrc to update the cached .jshintrc config, when file content changes.
      fs.watch(this.filepath, function(event, filename) {
        _this.update();
      });
      this.update();
    }
    return this.config;
  }
  
  tern.registerPlugin("jshint", function(server, options) {  
    server.mod.jshint = {
      config: new JSHintConfig(server, options)
    }
  });
  
  function validate(server, query, file, messages) {
	function isIgnored(file) {
      // JSHint ignore is potentially in a .jshintignore config file.
      var jshintignoreFileName = ".jshintignore"; 	
      var fs = require("fs");
      var filepath = normPath(jshintignoreFileName);
      if (!fs.existsSync(filepath)) {
        // If .jshintignore does not exist, then simply
    	// ask cli.gather if filename should be excluded
    	var gather = cli.gather({
    	  args: [file.name]
    	});
    	return gather.indexOf(file.name) < 0;
      }
      
      // We reach here if .jshintignore actually exists, but it needs special handling because
      // there is a problem that is caused when a directory wants to be excluded entirely and 
      // you only know a single filename (as this case). 
      // For that scenario, the ignore path needs to be explicitly specified as 
      // "folder/**" in .jshintignore instead just "folder/" or "folder", and given 
      // tern makes individual file calls, we need to provide a workaround here
      // for tern.java
    	  
      // Re-parse .jshintignore file
      var shjs = require("shelljs");
      var ignorePatterns = shjs.cat(filepath).split("\n");
      // Remove empty entries
      ignorePatterns = ignorePatterns.filter(function(line) {
	    return !!line.trim();
	  }).map (function(line) {
	    if (slashAtEndRegEx.test (line)) {
		  // This is a directory name (it ends with a slash), so help the 
	      // pattern adding the double asterisk at the end
		  return line += "**";
		} else {
		  // Get only the last segment for this path
		  var lastSegment = line.match(pathLastSegmentIsolationRegEx)[1];
		  // If this is a directory (which we identify by reviewing
		  // it's not a filename (i.e it has no extension), neither
		  // the expresion ends with ** then help improving the 
		  // ignore expression by adding a /** to the pattern
		  if (lastSegment && !fileNameRegEx.test (lastSegment)
				  && !doubleAsteriskAtEndRegEx.test (lastSegment)) {
			return line += "/**";
		  }
	    }
	      
	    // Otherwise, just pass the line with no modification
	    // This should be the case for explicit filenames
	    return line;
      });
    	
      var gather = cli.gather({
        args: [file.name],
      	ignores : ignorePatterns
      });
    	
      return gather.indexOf(file.name) < 0;
    }
	
    function getSeverity(error) {
      switch(error.severity) {
        case 1:
          return "warning";
        case 2:
          return "error";     
        default:
          return "error";
      }    
    }

    function makeError(message) {
	  var from = tern.resolvePos(file, {line: message.line - 1, ch: message.start}), to = from; 
	  try {
	    to = tern.resolvePos(file, {line: message.line - 1, ch: message.end});
	  } catch(e) {}
  	  var error = {
	    message: message.description,
	    severity: getSeverity(message),
	    from: tern.outputPos(query, file, from),
	    to: tern.outputPos(query, file, to)	      
	  }
  	  if (query.lineNumber) error.lineNumber = message.line;
	  if (!query.groupByFiles) error.file = file.name;
	  return error;
    }

    function parseErrors(errors, output) {
      for ( var i = 0; i < errors.length; i++) {
        var error = errors[i];
        if (error) {
          var linetabpositions, index;
  
          linetabpositions = [];
  
          // This next block is to fix a problem in jshint. Jshint
          // replaces
          // all tabs with spaces then performs some checks. The error
          // positions (character/space) are then reported incorrectly,
          // not taking the replacement step into account. Here we look
          // at the evidence line and try to adjust the character position
          // to the correct value.
          if (error.evidence) {
            // Tab positions are computed once per line and cached
            var tabpositions = linetabpositions[error.line];
            if (!tabpositions) {
              var evidence = error.evidence;
              tabpositions = [];
              // ugggh phantomjs does not like this
              // forEachChar(evidence, function(item, index) {
                Array.prototype.forEach.call(evidence, function(item,
                                                              index) {
                if (item === '\t') {
                  // First col is 1 (not 0) to match error
                  // positions
                  tabpositions.push(index + 1);
                }
              });
              linetabpositions[error.line] = tabpositions;
            }
            if (tabpositions.length > 0) {
              var pos = error.character;
              tabpositions.forEach(function(tabposition) {
                if (pos > tabposition) pos -= 1;
              });
              error.character = pos;
            }
          }
  
          var start = error.character - 1, end = start + 1;
          if (error.evidence) {
            index = error.evidence.substring(start).search(/.\b/);
            if (index > -1) {
              end += index;
            }
          }

          // Convert to format expected by validation service
          error.description = error.reason;// + "(jshint)";
          error.start = start;
          error.end = end;
          error = cleanup(error);
  
          if (error)
            output.push(makeError(error));
        }
      }
    }
    
    if (isIgnored(file)) {
      // Just skip, this file does not need to be linted
      return;
    }
  
	var text = file.text, jshintCfg = server.mod.jshint.config;
	var config = jshintCfg.getConfig(), globals = jshintCfg.globals;
	if (jshintCfg.error) {
	  // .jshintrc file doesn't exist
	  messages.push(makeError({line:1 , start: 0, end: 1, description: jshintCfg.error, severity: "error"}))
	} else {
	  JSHINT(text, config, globals);
	  var errors = JSHINT.data().errors;
	  if (errors) parseErrors(errors, messages);	  
	}
  }
  
  tern.defineQueryType("jshint", {
    takesFile: true,
    run: function(server, query, file) {
      try {
        var messages = [];
        validate(server, query, file, messages);
        return {messages: messages};
      } catch(err) {
        console.error(err.stack);
        return {messages: []};
      }        
    }
  });
  
  tern.defineQueryType("jshint-full", {
    run: function(server, query) {
      try {
        var messages = [], files = server.files, groupByFiles = query.groupByFiles == true;
        for (var i = 0; i < files.length; ++i) {
          var messagesFile = groupByFiles ? [] : messages, file = files[i];
          validate(server, query, file, messagesFile);
          if (groupByFiles) messages.push({file:file.name, messages: messagesFile});
        }        
        return {messages: messages};
      } catch(err) {
        console.error(err.stack);
        return {messages: []};
      }
    }
  });
  
});